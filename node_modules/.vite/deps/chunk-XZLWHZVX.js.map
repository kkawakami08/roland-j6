{
  "version": 3,
  "sources": ["../../@tonaljs/pitch-note/node_modules/@tonaljs/pitch/index.ts", "../../@tonaljs/pitch-note/index.ts", "../../@tonaljs/midi/index.ts", "../../@tonaljs/pitch-distance/node_modules/@tonaljs/pitch/index.ts", "../../@tonaljs/pitch-distance/node_modules/@tonaljs/pitch-interval/index.ts", "../../@tonaljs/pitch-distance/index.ts", "../../@tonaljs/note/index.ts"],
  "sourcesContent": ["export interface NamedPitch {\n  readonly name: string;\n}\n\n/*** @deprecated use NamedPitch */\nexport interface Named {\n  readonly name: string;\n}\n\nexport interface NotFound extends NamedPitch {\n  readonly empty: true;\n  readonly name: \"\";\n}\n\nexport function isNamedPitch(src: unknown): src is NamedPitch {\n  return src !== null &&\n    typeof src === \"object\" &&\n    \"name\" in src &&\n    typeof src.name === \"string\"\n    ? true\n    : false;\n}\n\ntype Fifths = number;\ntype Octaves = number;\nexport type Direction = 1 | -1;\n\nexport type PitchClassCoordinates = [Fifths];\nexport type NoteCoordinates = [Fifths, Octaves];\nexport type IntervalCoordinates = [Fifths, Octaves, Direction];\nexport type PitchCoordinates =\n  | PitchClassCoordinates\n  | NoteCoordinates\n  | IntervalCoordinates;\n\n/**\n * Pitch properties\n *\n * - {number} step - The step number: 0 = C, 1 = D, ... 6 = B\n * - {number} alt - Number of alterations: -2 = 'bb', -1 = 'b', 0 = '', 1 = '#', ...\n * - {number} [oct] = The octave (undefined when is a coord class)\n * - {number} [dir] = Interval direction (undefined when is not an interval)\n */\nexport interface Pitch {\n  readonly step: number;\n  readonly alt: number;\n  readonly oct?: number; // undefined for pitch classes\n  readonly dir?: Direction; // undefined for notes\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nexport const chroma = ({ step, alt }: Pitch) => (SIZES[step] + alt + 120) % 12;\n\nexport const height = ({ step, alt, oct, dir = 1 }: Pitch) =>\n  dir * (SIZES[step] + alt + 12 * (oct === undefined ? -100 : oct));\n\nexport const midi = (pitch: Pitch) => {\n  const h = height(pitch);\n  return pitch.oct !== undefined && h >= -12 && h <= 115 ? h + 12 : null;\n};\n\nexport function isPitch(pitch: unknown): pitch is Pitch {\n  return pitch !== null &&\n    typeof pitch === \"object\" &&\n    \"step\" in pitch &&\n    typeof pitch.step === \"number\" &&\n    \"alt\" in pitch &&\n    typeof pitch.alt === \"number\" &&\n    !isNaN(pitch.step) &&\n    !isNaN(pitch.alt)\n    ? true\n    : false;\n}\n\n// The number of fifths of [C, D, E, F, G, A, B]\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// The number of octaves it span each step\nconst STEPS_TO_OCTS = FIFTHS.map((fifths: number) =>\n  Math.floor((fifths * 7) / 12),\n);\n\n/**\n * Get coordinates from pitch object\n */\nexport function coordinates(pitch: Pitch): PitchCoordinates {\n  const { step, alt, oct, dir = 1 } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === undefined) {\n    return [dir * f];\n  }\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\nconst FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n/**\n * Get pitch from coordinate objects\n */\nexport function pitch(coord: PitchCoordinates): Pitch {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === undefined) {\n    return { step, alt, dir };\n  }\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return { step, alt, oct, dir };\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f: number): number {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n", "import {\n  coordinates,\n  isNamedPitch,\n  isPitch,\n  NamedPitch,\n  Pitch,\n  pitch,\n  PitchCoordinates,\n} from \"@tonaljs/pitch\";\n\nconst fillStr = (s: string, n: number) => Array(Math.abs(n) + 1).join(s);\n\nexport type NoteWithOctave = string;\nexport type PcName = string;\nexport type NoteName = NoteWithOctave | PcName;\nexport type NoteLiteral = NoteName | Pitch | NamedPitch;\n\nexport interface Note extends Pitch, NamedPitch {\n  readonly empty: boolean;\n  readonly name: NoteName;\n  readonly letter: string;\n  readonly acc: string;\n  readonly pc: PcName;\n  readonly chroma: number;\n  readonly height: number;\n  readonly coord: PitchCoordinates;\n  readonly midi: number | null;\n  readonly freq: number | null;\n}\n\nconst NoNote: Note = Object.freeze({\n  empty: true,\n  name: \"\",\n  letter: \"\",\n  acc: \"\",\n  pc: \"\",\n  step: NaN,\n  alt: NaN,\n  chroma: NaN,\n  height: NaN,\n  coord: [] as unknown as PitchCoordinates,\n  midi: null,\n  freq: null,\n});\n\nconst cache: Map<NoteLiteral | undefined, Note> = new Map();\n\nexport const stepToLetter = (step: number) => \"CDEFGAB\".charAt(step);\nexport const altToAcc = (alt: number): string =>\n  alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt);\nexport const accToAlt = (acc: string): number =>\n  acc[0] === \"b\" ? -acc.length : acc.length;\n\n/**\n * Given a note literal (a note name or a note object), returns the Note object\n * @example\n * note('Bb4') // => { name: \"Bb4\", midi: 70, chroma: 10, ... }\n */\nexport function note(src: NoteLiteral): Note {\n  const stringSrc = JSON.stringify(src);\n\n  const cached = cache.get(stringSrc);\n  if (cached) {\n    return cached;\n  }\n\n  const value =\n    typeof src === \"string\"\n      ? parse(src)\n      : isPitch(src)\n        ? note(pitchName(src))\n        : isNamedPitch(src)\n          ? note(src.name)\n          : NoNote;\n  cache.set(stringSrc, value);\n  return value;\n}\n\ntype NoteTokens = [string, string, string, string];\n\nconst REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\n\n/**\n * @private\n */\nexport function tokenizeNote(str: string): NoteTokens {\n  const m = REGEX.exec(str) as string[];\n  return m\n    ? [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]]\n    : [\"\", \"\", \"\", \"\"];\n}\n\n/**\n * @private\n */\nexport function coordToNote(noteCoord: PitchCoordinates): Note {\n  return note(pitch(noteCoord)) as Note;\n}\n\nconst mod = (n: number, m: number) => ((n % m) + m) % m;\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\nfunction parse(noteName: NoteName): Note {\n  const tokens = tokenizeNote(noteName);\n  if (tokens[0] === \"\" || tokens[3] !== \"\") {\n    return NoNote;\n  }\n\n  const letter = tokens[0];\n  const acc = tokens[1];\n  const octStr = tokens[2];\n\n  const step = (letter.charCodeAt(0) + 3) % 7;\n  const alt = accToAlt(acc);\n  const oct = octStr.length ? +octStr : undefined;\n  const coord = coordinates({ step, alt, oct });\n\n  const name = letter + acc + octStr;\n  const pc = letter + acc;\n  const chroma = (SEMI[step] + alt + 120) % 12;\n  const height =\n    oct === undefined\n      ? mod(SEMI[step] + alt, 12) - 12 * 99\n      : SEMI[step] + alt + 12 * (oct + 1);\n  const midi = height >= 0 && height <= 127 ? height : null;\n  const freq = oct === undefined ? null : Math.pow(2, (height - 69) / 12) * 440;\n\n  return {\n    empty: false,\n    acc,\n    alt,\n    chroma,\n    coord,\n    freq,\n    height,\n    letter,\n    midi,\n    name,\n    oct,\n    pc,\n    step,\n  };\n}\n\nfunction pitchName(props: Pitch): NoteName {\n  const { step, alt, oct } = props;\n  const letter = stepToLetter(step);\n  if (!letter) {\n    return \"\";\n  }\n\n  const pc = letter + altToAcc(alt);\n  return oct || oct === 0 ? pc + oct : pc;\n}\n", "import { NoteName, note as props } from \"@tonaljs/pitch-note\";\n\ntype Midi = number;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isMidi(arg: any): arg is Midi {\n  return +arg >= 0 && +arg <= 127;\n}\n\n/**\n * Get the note midi number (a number between 0 and 127)\n *\n * It returns undefined if not valid note name\n *\n * @function\n * @param {string|number} note - the note name or midi number\n * @return {Integer} the midi number or undefined if not valid note\n * @example\n * import { toMidi } from '@tonaljs/midi'\n * toMidi(\"C4\") // => 60\n * toMidi(60) // => 60\n * toMidi('60') // => 60\n */\nexport function toMidi(note: NoteName | number): number | null {\n  if (isMidi(note)) {\n    return +note;\n  }\n  const n = props(note);\n  return n.empty ? null : n.midi;\n}\n\n/**\n * Get the frequency in hertzs from midi number\n *\n * @param {number} midi - the note midi number\n * @param {number} [tuning = 440] - A4 tuning frequency in Hz (440 by default)\n * @return {number} the frequency or null if not valid note midi\n * @example\n * import { midiToFreq} from '@tonaljs/midi'\n * midiToFreq(69) // => 440\n */\nexport function midiToFreq(midi: number, tuning = 440): number {\n  return Math.pow(2, (midi - 69) / 12) * tuning;\n}\n\nconst L2 = Math.log(2);\nconst L440 = Math.log(440);\n\n/**\n * Get the midi number from a frequency in hertz. The midi number can\n * contain decimals (with two digits precision)\n *\n * @param {number} frequency\n * @return {number}\n * @example\n * import { freqToMidi} from '@tonaljs/midi'\n * freqToMidi(220)); //=> 57\n * freqToMidi(261.62)); //=> 60\n * freqToMidi(261)); //=> 59.96\n */\nexport function freqToMidi(freq: number): number {\n  const v = (12 * (Math.log(freq) - L440)) / L2 + 69;\n  return Math.round(v * 100) / 100;\n}\n\nexport interface ToNoteNameOptions {\n  pitchClass?: boolean;\n  sharps?: boolean;\n}\n\nconst SHARPS = \"C C# D D# E F F# G G# A A# B\".split(\" \");\nconst FLATS = \"C Db D Eb E F Gb G Ab A Bb B\".split(\" \");\n/**\n * Given a midi number, returns a note name. The altered notes will have\n * flats unless explicitly set with the optional `useSharps` parameter.\n *\n * @function\n * @param {number} midi - the midi note number\n * @param {Object} options = default: `{ sharps: false, pitchClass: false }`\n * @param {boolean} useSharps - (Optional) set to true to use sharps instead of flats\n * @return {string} the note name\n * @example\n * import { midiToNoteName } from '@tonaljs/midi'\n * midiToNoteName(61) // => \"Db4\"\n * midiToNoteName(61, { pitchClass: true }) // => \"Db\"\n * midiToNoteName(61, { sharps: true }) // => \"C#4\"\n * midiToNoteName(61, { pitchClass: true, sharps: true }) // => \"C#\"\n * // it rounds to nearest note\n * midiToNoteName(61.7) // => \"D4\"\n */\nexport function midiToNoteName(midi: number, options: ToNoteNameOptions = {}) {\n  if (isNaN(midi) || midi === -Infinity || midi === Infinity) return \"\";\n  midi = Math.round(midi);\n  const pcs = options.sharps === true ? SHARPS : FLATS;\n  const pc = pcs[midi % 12];\n  if (options.pitchClass) {\n    return pc;\n  }\n  const o = Math.floor(midi / 12) - 1;\n  return pc + o;\n}\n\nexport function chroma(midi: number): number {\n  return midi % 12;\n}\n\nfunction pcsetFromChroma(chroma: string): number[] {\n  return chroma.split(\"\").reduce((pcset, val, index) => {\n    if (index < 12 && val === \"1\") pcset.push(index);\n    return pcset;\n  }, [] as number[]);\n}\n\nfunction pcsetFromMidi(midi: number[]): number[] {\n  return midi\n    .map(chroma)\n    .sort((a, b) => a - b)\n    .filter((n, i, a) => i === 0 || n !== a[i - 1]);\n}\n\n/**\n * Given a list of midi numbers, returns the pitch class set (unique chroma numbers)\n * @param midi\n * @example\n *\n */\nexport function pcset(notes: number[] | string): number[] {\n  return Array.isArray(notes) ? pcsetFromMidi(notes) : pcsetFromChroma(notes);\n}\n\nexport function pcsetNearest(notes: number[] | string) {\n  const set = pcset(notes);\n  return (midi: number): number | undefined => {\n    const ch = chroma(midi);\n    for (let i = 0; i < 12; i++) {\n      if (set.includes(ch + i)) return midi + i;\n      if (set.includes(ch - i)) return midi - i;\n    }\n    return undefined;\n  };\n}\n\nexport function pcsetSteps(notes: number[] | string, tonic: number) {\n  const set = pcset(notes);\n  const len = set.length;\n  return (step: number): number => {\n    const index = step < 0 ? (len - (-step % len)) % len : step % len;\n    const octaves = Math.floor(step / len);\n    return set[index] + octaves * 12 + tonic;\n  };\n}\n\nexport function pcsetDegrees(notes: number[] | string, tonic: number) {\n  const steps = pcsetSteps(notes, tonic);\n  return (degree: number): number | undefined => {\n    if (degree === 0) return undefined;\n    return steps(degree > 0 ? degree - 1 : degree);\n  };\n}\n\n/** @deprecated */\nexport default {\n  chroma,\n  freqToMidi,\n  isMidi,\n  midiToFreq,\n  midiToNoteName,\n  pcsetNearest,\n  pcset,\n  pcsetDegrees,\n  pcsetSteps,\n  toMidi,\n};\n", "export interface NamedPitch {\n  readonly name: string;\n}\n\n/*** @deprecated use NamedPitch */\nexport interface Named {\n  readonly name: string;\n}\n\nexport interface NotFound extends NamedPitch {\n  readonly empty: true;\n  readonly name: \"\";\n}\n\nexport function isNamedPitch(src: unknown): src is NamedPitch {\n  return src !== null &&\n    typeof src === \"object\" &&\n    \"name\" in src &&\n    typeof src.name === \"string\"\n    ? true\n    : false;\n}\n\ntype Fifths = number;\ntype Octaves = number;\nexport type Direction = 1 | -1;\n\nexport type PitchClassCoordinates = [Fifths];\nexport type NoteCoordinates = [Fifths, Octaves];\nexport type IntervalCoordinates = [Fifths, Octaves, Direction];\nexport type PitchCoordinates =\n  | PitchClassCoordinates\n  | NoteCoordinates\n  | IntervalCoordinates;\n\n/**\n * Pitch properties\n *\n * - {number} step - The step number: 0 = C, 1 = D, ... 6 = B\n * - {number} alt - Number of alterations: -2 = 'bb', -1 = 'b', 0 = '', 1 = '#', ...\n * - {number} [oct] = The octave (undefined when is a coord class)\n * - {number} [dir] = Interval direction (undefined when is not an interval)\n */\nexport interface Pitch {\n  readonly step: number;\n  readonly alt: number;\n  readonly oct?: number; // undefined for pitch classes\n  readonly dir?: Direction; // undefined for notes\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nexport const chroma = ({ step, alt }: Pitch) => (SIZES[step] + alt + 120) % 12;\n\nexport const height = ({ step, alt, oct, dir = 1 }: Pitch) =>\n  dir * (SIZES[step] + alt + 12 * (oct === undefined ? -100 : oct));\n\nexport const midi = (pitch: Pitch) => {\n  const h = height(pitch);\n  return pitch.oct !== undefined && h >= -12 && h <= 115 ? h + 12 : null;\n};\n\nexport function isPitch(pitch: unknown): pitch is Pitch {\n  return pitch !== null &&\n    typeof pitch === \"object\" &&\n    \"step\" in pitch &&\n    typeof pitch.step === \"number\" &&\n    \"alt\" in pitch &&\n    typeof pitch.alt === \"number\" &&\n    !isNaN(pitch.step) &&\n    !isNaN(pitch.alt)\n    ? true\n    : false;\n}\n\n// The number of fifths of [C, D, E, F, G, A, B]\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// The number of octaves it span each step\nconst STEPS_TO_OCTS = FIFTHS.map((fifths: number) =>\n  Math.floor((fifths * 7) / 12),\n);\n\n/**\n * Get coordinates from pitch object\n */\nexport function coordinates(pitch: Pitch): PitchCoordinates {\n  const { step, alt, oct, dir = 1 } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === undefined) {\n    return [dir * f];\n  }\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\nconst FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\n\n/**\n * Get pitch from coordinate objects\n */\nexport function pitch(coord: PitchCoordinates): Pitch {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === undefined) {\n    return { step, alt, dir };\n  }\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return { step, alt, oct, dir };\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f: number): number {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n", "import {\n  coordinates,\n  Direction,\n  IntervalCoordinates,\n  isNamedPitch,\n  isPitch,\n  NamedPitch,\n  Pitch,\n  pitch,\n  PitchCoordinates,\n} from \"@tonaljs/pitch\";\n\nconst fillStr = (s: string, n: number) => Array(Math.abs(n) + 1).join(s);\n\nexport type IntervalName = string;\nexport type IntervalLiteral = IntervalName | Pitch | NamedPitch;\n\ntype Quality =\n  | \"dddd\"\n  | \"ddd\"\n  | \"dd\"\n  | \"d\"\n  | \"m\"\n  | \"M\"\n  | \"P\"\n  | \"A\"\n  | \"AA\"\n  | \"AAA\"\n  | \"AAAA\";\ntype Type = \"perfectable\" | \"majorable\";\n\nexport interface Interval extends Pitch, NamedPitch {\n  readonly empty: boolean;\n  readonly name: IntervalName;\n  readonly num: number;\n  readonly q: Quality;\n  readonly type: Type;\n  readonly step: number;\n  readonly alt: number;\n  readonly dir: Direction;\n  readonly simple: number;\n  readonly semitones: number;\n  readonly chroma: number;\n  readonly coord: IntervalCoordinates;\n  readonly oct: number;\n}\n\nconst NoInterval: Interval = Object.freeze({\n  empty: true,\n  name: \"\",\n  num: NaN,\n  q: \"\" as Quality,\n  type: \"\" as Type,\n  step: NaN,\n  alt: NaN,\n  dir: NaN as Direction,\n  simple: NaN,\n  semitones: NaN,\n  chroma: NaN,\n  coord: [] as unknown as IntervalCoordinates,\n  oct: NaN,\n});\n\n// shorthand tonal notation (with quality after number)\nconst INTERVAL_TONAL_REGEX = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\n// standard shorthand notation (with quality before number)\nconst INTERVAL_SHORTHAND_REGEX = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nconst REGEX = new RegExp(\n  \"^\" + INTERVAL_TONAL_REGEX + \"|\" + INTERVAL_SHORTHAND_REGEX + \"$\",\n);\n\ntype IntervalTokens = [string, string];\n\n/**\n * @private\n */\nexport function tokenizeInterval(str?: IntervalName): IntervalTokens {\n  const m = REGEX.exec(`${str}`);\n  if (m === null) {\n    return [\"\", \"\"];\n  }\n  return m[1] ? [m[1], m[2]] : [m[4], m[3]];\n}\n\nconst cache: { [key in string]: Interval } = {};\n\n/**\n * Get interval properties. It returns an object with:\n *\n * - name: the interval name\n * - num: the interval number\n * - type: 'perfectable' or 'majorable'\n * - q: the interval quality (d, m, M, A)\n * - dir: interval direction (1 ascending, -1 descending)\n * - simple: the simplified number\n * - semitones: the size in semitones\n * - chroma: the interval chroma\n *\n * @param {string} interval - the interval name\n * @return {Object} the interval properties\n *\n * @example\n * import { interval } from '@tonaljs/core'\n * interval('P5').semitones // => 7\n * interval('m3').type // => 'majorable'\n */\nexport function interval(src: IntervalLiteral): Interval {\n  return typeof src === \"string\"\n    ? cache[src] || (cache[src] = parse(src))\n    : isPitch(src)\n      ? interval(pitchName(src))\n      : isNamedPitch(src)\n        ? interval(src.name)\n        : NoInterval;\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nconst TYPES = \"PMMPPMM\";\nfunction parse(str?: string): Interval {\n  const tokens = tokenizeInterval(str);\n  if (tokens[0] === \"\") {\n    return NoInterval;\n  }\n  const num = +tokens[0];\n  const q = tokens[1] as Quality;\n  const step = (Math.abs(num) - 1) % 7;\n  const t = TYPES[step];\n  if (t === \"M\" && q === \"P\") {\n    return NoInterval;\n  }\n  const type = t === \"M\" ? \"majorable\" : \"perfectable\";\n\n  const name = \"\" + num + q;\n  const dir = num < 0 ? -1 : 1;\n  const simple = num === 8 || num === -8 ? num : dir * (step + 1);\n  const alt = qToAlt(type, q);\n  const oct = Math.floor((Math.abs(num) - 1) / 7);\n  const semitones = dir * (SIZES[step] + alt + 12 * oct);\n  const chroma = (((dir * (SIZES[step] + alt)) % 12) + 12) % 12;\n  const coord = coordinates({ step, alt, oct, dir }) as IntervalCoordinates;\n  return {\n    empty: false,\n    name,\n    num,\n    q,\n    step,\n    alt,\n    dir,\n    type,\n    simple,\n    semitones,\n    chroma,\n    coord,\n    oct,\n  };\n}\n\n/**\n * @private\n *\n * forceDescending is used in the case of unison (#243)\n */\nexport function coordToInterval(\n  coord: PitchCoordinates,\n  forceDescending?: boolean,\n): Interval {\n  const [f, o = 0] = coord;\n  const isDescending = f * 7 + o * 12 < 0;\n  const ivl: IntervalCoordinates =\n    forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];\n  return interval(pitch(ivl)) as Interval;\n}\n\nfunction qToAlt(type: Type, q: string): number {\n  return (q === \"M\" && type === \"majorable\") ||\n    (q === \"P\" && type === \"perfectable\")\n    ? 0\n    : q === \"m\" && type === \"majorable\"\n      ? -1\n      : /^A+$/.test(q)\n        ? q.length\n        : /^d+$/.test(q)\n          ? -1 * (type === \"perfectable\" ? q.length : q.length + 1)\n          : 0;\n}\n\n// return the interval name of a pitch\nfunction pitchName(props: Pitch): string {\n  const { step, alt, oct = 0, dir } = props;\n  if (!dir) {\n    return \"\";\n  }\n  const calcNum = step + 1 + 7 * oct;\n  // this is an edge case: descending pitch class unison (see #243)\n  const num = calcNum === 0 ? step + 1 : calcNum;\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[step] === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = d + num + altToQ(type, alt);\n  return name;\n}\n\nfunction altToQ(type: Type, alt: number): Quality {\n  if (alt === 0) {\n    return type === \"majorable\" ? \"M\" : \"P\";\n  } else if (alt === -1 && type === \"majorable\") {\n    return \"m\";\n  } else if (alt > 0) {\n    return fillStr(\"A\", alt) as Quality;\n  } else {\n    return fillStr(\"d\", type === \"perfectable\" ? alt : alt + 1) as Quality;\n  }\n}\n", "import { PitchCoordinates } from \"@tonaljs/pitch\";\nimport {\n  IntervalLiteral,\n  IntervalName,\n  interval as asInterval,\n  coordToInterval,\n} from \"@tonaljs/pitch-interval\";\nimport {\n  NoteLiteral,\n  NoteName,\n  note as asNote,\n  coordToNote,\n} from \"@tonaljs/pitch-note\";\n\n/**\n * Transpose a note by an interval.\n *\n * @param {string} note - the note or note name\n * @param {string} interval - the interval or interval name\n * @return {string} the transposed note name or empty string if not valid notes\n * @example\n * import { transpose } from \"@tonaljs/core\"\n * transpose(\"d3\", \"3M\") // => \"F#3\"\n * transpose(\"D\", \"3M\") // => \"F#\"\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(pc => transpose(pc, \"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\n */\nexport function transpose(\n  noteName: NoteLiteral,\n  intervalName: IntervalLiteral | [number, number],\n): NoteName {\n  const note = asNote(noteName);\n  const intervalCoord = Array.isArray(intervalName)\n    ? intervalName\n    : asInterval(intervalName).coord;\n  if (note.empty || !intervalCoord || intervalCoord.length < 2) {\n    return \"\";\n  }\n  const noteCoord = note.coord;\n  const tr: PitchCoordinates =\n    noteCoord.length === 1\n      ? [noteCoord[0] + intervalCoord[0]]\n      : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];\n  return coordToNote(tr).name;\n}\n\n// Private\nexport function tonicIntervalsTransposer(\n  intervals: string[],\n  tonic: string | undefined | null,\n) {\n  const len = intervals.length;\n  return (normalized: number) => {\n    if (!tonic) return \"\";\n    const index =\n      normalized < 0 ? (len - (-normalized % len)) % len : normalized % len;\n    const octaves = Math.floor(normalized / len);\n    const root = transpose(tonic, [0, octaves]);\n    return transpose(root, intervals[index]);\n  };\n}\n\n/**\n * Find the interval distance between two notes or coord classes.\n *\n * To find distance between coord classes, both notes must be coord classes and\n * the interval is always ascending\n *\n * @param {Note|string} from - the note or note name to calculate distance from\n * @param {Note|string} to - the note or note name to calculate distance to\n * @return {string} the interval name or empty string if not valid notes\n *\n */\nexport function distance(\n  fromNote: NoteLiteral,\n  toNote: NoteLiteral,\n): IntervalName {\n  const from = asNote(fromNote);\n  const to = asNote(toNote);\n  if (from.empty || to.empty) {\n    return \"\";\n  }\n\n  const fcoord = from.coord;\n  const tcoord = to.coord;\n  const fifths = tcoord[0] - fcoord[0];\n  const octs =\n    fcoord.length === 2 && tcoord.length === 2\n      ? tcoord[1] - fcoord[1]\n      : -Math.floor((fifths * 7) / 12);\n\n  // If it's unison, not pitch class, and in the same octave\n  // it can be descending interval (see #243 & #428)\n  const forceDescending =\n    to.height === from.height &&\n    to.midi !== null &&\n    from.oct === to.oct &&\n    from.step > to.step;\n  return coordToInterval([fifths, octs], forceDescending).name;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { freqToMidi, midiToNoteName } from \"@tonaljs/midi\";\nimport { Pitch } from \"@tonaljs/pitch\";\nimport { distance as _dist, transpose as _tr } from \"@tonaljs/pitch-distance\";\nimport { IntervalName } from \"@tonaljs/pitch-interval\";\nimport {\n  Note,\n  NoteLiteral,\n  NoteName,\n  note as props,\n} from \"@tonaljs/pitch-note\";\n\nconst NAMES = [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"];\n\nconst toName = (n: Note) => n.name;\nconst onlyNotes = (array: any[]) =>\n  array.map(props).filter((n) => !n.empty) as Note[];\n\n/**\n * Return the natural note names without octave\n * @function\n * @example\n * Note.names(); // => [\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\"]\n */\nexport function names(array?: any[]): string[] {\n  if (array === undefined) {\n    return NAMES.slice();\n  } else if (!Array.isArray(array)) {\n    return [];\n  } else {\n    return onlyNotes(array).map(toName);\n  }\n}\n\n/**\n * Get a note from a note name\n *\n * @function\n * @example\n * Note.get('Bb4') // => { name: \"Bb4\", midi: 70, chroma: 10, ... }\n */\nexport const get = props;\n\n/**\n * Get the note name\n * @function\n */\nexport const name = (note: NoteLiteral) => get(note).name;\n\n/**\n * Get the note pitch class name\n * @function\n */\nexport const pitchClass = (note: NoteLiteral) => get(note).pc;\n\n/**\n * Get the note accidentals\n * @function\n */\nexport const accidentals = (note: NoteLiteral) => get(note).acc;\n\n/**\n * Get the note octave\n * @function\n */\nexport const octave = (note: NoteLiteral) => get(note).oct;\n\n/**\n * Get the note midi\n * @function\n */\nexport const midi = (note: NoteLiteral) => get(note).midi;\n\n/**\n * Get the note midi\n * @function\n */\nexport const freq = (note: NoteLiteral) => get(note).freq;\n\n/**\n * Get the note chroma\n * @function\n */\nexport const chroma = (note: NoteLiteral) => get(note).chroma;\n\n/**\n * Given a midi number, returns a note name. Uses flats for altered notes.\n *\n * @function\n * @param {number} midi - the midi note number\n * @return {string} the note name\n * @example\n * Note.fromMidi(61) // => \"Db4\"\n * Note.fromMidi(61.7) // => \"D4\"\n */\nexport function fromMidi(midi: number) {\n  return midiToNoteName(midi);\n}\n\n/**\n * Given a midi number, returns a note name. Uses flats for altered notes.\n */\nexport function fromFreq(freq: number) {\n  return midiToNoteName(freqToMidi(freq));\n}\n/**\n * Given a midi number, returns a note name. Uses flats for altered notes.\n */\nexport function fromFreqSharps(freq: number) {\n  return midiToNoteName(freqToMidi(freq), { sharps: true });\n}\n\n/**\n * Given a midi number, returns a note name. Uses flats for altered notes.\n *\n * @function\n * @param {number} midi - the midi note number\n * @return {string} the note name\n * @example\n * Note.fromMidiSharps(61) // => \"C#4\"\n */\n\nexport function fromMidiSharps(midi: number) {\n  return midiToNoteName(midi, { sharps: true });\n}\n\nexport const distance = _dist;\n\n/**\n * Transpose a note by an interval\n */\nexport const transpose = _tr;\nexport const tr = _tr;\n\n/**\n * Transpose by an interval.\n * @function\n * @param {string} interval\n * @return {function} a function that transposes by the given interval\n * @example\n * [\"C\", \"D\", \"E\"].map(Note.transposeBy(\"5P\"));\n * // => [\"G\", \"A\", \"B\"]\n */\nexport const transposeBy = (interval: IntervalName) => (note: NoteName) =>\n  transpose(note, interval);\nexport const trBy = transposeBy;\n\n/**\n * Transpose from a note\n * @function\n * @param {string} note\n * @return {function}  a function that transposes the the note by an interval\n * [\"1P\", \"3M\", \"5P\"].map(Note.transposeFrom(\"C\"));\n * // => [\"C\", \"E\", \"G\"]\n */\nexport const transposeFrom = (note: NoteName) => (interval: IntervalName) =>\n  transpose(note, interval);\nexport const trFrom = transposeFrom;\n\n/**\n * Transpose a note by a number of perfect fifths.\n *\n * @function\n * @param {string} note - the note name\n * @param {number} fifhts - the number of fifths\n * @return {string} the transposed note name\n *\n * @example\n * import { transposeFifths } from \"@tonaljs/note\"\n * transposeFifths(\"G4\", 1) // => \"D\"\n * [0, 1, 2, 3, 4].map(fifths => transposeFifths(\"C\", fifths)) // => [\"C\", \"G\", \"D\", \"A\", \"E\"]\n */\nexport function transposeFifths(noteName: NoteName, fifths: number): NoteName {\n  return transpose(noteName, [fifths, 0]);\n}\nexport const trFifths = transposeFifths;\n\n// TODO: documentation\nexport function transposeOctaves(\n  noteName: NoteName,\n  octaves: number,\n): NoteName {\n  return transpose(noteName, [0, octaves]);\n}\n\nexport type NoteComparator = (a: Note, b: Note) => number;\n\nexport const ascending: NoteComparator = (a, b) => a.height - b.height;\nexport const descending: NoteComparator = (a, b) => b.height - a.height;\n\nexport function sortedNames(\n  notes: any[],\n  comparator?: NoteComparator,\n): string[] {\n  comparator = comparator || ascending;\n  return onlyNotes(notes).sort(comparator).map(toName);\n}\n\nexport function sortedUniqNames(notes: any[]): string[] {\n  return sortedNames(notes, ascending).filter(\n    (n, i, a) => i === 0 || n !== a[i - 1],\n  );\n}\n\n/**\n * Simplify a note\n *\n * @function\n * @param {string} note - the note to be simplified\n * - sameAccType: default true. Use same kind of accidentals that source\n * @return {string} the simplified note or '' if not valid note\n * @example\n * simplify(\"C##\") // => \"D\"\n * simplify(\"C###\") // => \"D#\"\n * simplify(\"C###\")\n * simplify(\"B#4\") // => \"C5\"\n */\nexport const simplify = (noteName: NoteName | Pitch): string => {\n  const note = get(noteName);\n  if (note.empty) {\n    return \"\";\n  }\n  return midiToNoteName(note.midi || note.chroma, {\n    sharps: note.alt > 0,\n    pitchClass: note.midi === null,\n  });\n};\n/**\n * Get enharmonic of a note\n *\n * @function\n * @param {string} note\n * @param [string] - [optional] Destination pitch class\n * @return {string} the enharmonic note name or '' if not valid note\n * @example\n * Note.enharmonic(\"Db\") // => \"C#\"\n * Note.enharmonic(\"C\") // => \"C\"\n * Note.enharmonic(\"F2\",\"E#\") // => \"E#2\"\n * Note.eharmoinic(\"C##b\"); // => \"\"\n */\nexport function enharmonic(noteName: string, destName?: string) {\n  const src = get(noteName);\n  if (src.empty) {\n    return \"\";\n  }\n\n  // destination: use given or generate one\n  const dest = get(\n    destName ||\n      midiToNoteName(src.midi || src.chroma, {\n        sharps: src.alt < 0,\n        pitchClass: true,\n      }),\n  );\n\n  // ensure destination is valid\n  if (dest.empty || dest.chroma !== src.chroma) {\n    return \"\";\n  }\n\n  // if src has no octave, no need to calculate anything else\n  if (src.oct === undefined) {\n    return dest.pc;\n  }\n\n  // detect any octave overflow\n  const srcChroma = src.chroma - src.alt;\n  const destChroma = dest.chroma - dest.alt;\n  const destOctOffset =\n    srcChroma > 11 || destChroma < 0\n      ? -1\n      : srcChroma < 0 || destChroma > 11\n        ? +1\n        : 0;\n  // calculate the new octave\n  const destOct = src.oct + destOctOffset;\n  return dest.pc + destOct;\n}\n\n/** @deprecated */\nexport default {\n  names,\n  get,\n  name,\n  pitchClass,\n  accidentals,\n  octave,\n  midi,\n  ascending,\n  descending,\n  distance,\n  sortedNames,\n  sortedUniqNames,\n  fromMidi,\n  fromMidiSharps,\n  freq,\n  fromFreq,\n  fromFreqSharps,\n  chroma,\n  transpose,\n  tr,\n  transposeBy,\n  trBy,\n  transposeFrom,\n  trFrom,\n  transposeFifths,\n  transposeOctaves,\n  trFifths,\n  simplify,\n  enharmonic,\n};\n"],
  "mappings": "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",
  "names": ["pitch", "name", "chroma", "midi", "freq", "note", "midi", "freq", "chroma", "pcset", "isNamedPitch", "isPitch", "pitch", "FIFTHS", "STEPS_TO_OCTS", "coordinates", "FIFTHS_TO_STEPS", "unaltered", "fillStr", "REGEX", "cache", "parse", "isPitch", "pitchName", "isNamedPitch", "name", "chroma", "coordinates", "pitch", "note", "tr", "note", "chroma", "midi", "freq", "distance", "transpose", "interval"]
}
