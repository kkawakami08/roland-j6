import {
  EmptyPcset,
  all,
  collection_default,
  compact,
  get,
  get2,
  isSubsetOf,
  isSupersetOf,
  modes,
  pcset_default,
  range,
  rotate,
  scale_default,
  scale_type_default
} from "./chunk-TUF3MBXI.js";
import {
  accToAlt,
  altToAcc,
  distance,
  midiToNoteName,
  midi_default,
  note,
  note_default,
  toMidi,
  tokenizeNote,
  transpose,
  transpose2,
  transposeFifths
} from "./chunk-OYM73DQZ.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/@tonaljs/abc-notation/dist/index.mjs
var fillStr = (character, times) => Array(times + 1).join(character);
var REGEX = /^(_{1,}|=|\^{1,}|)([abcdefgABCDEFG])([,']*)$/;
function tokenize(str) {
  const m = REGEX.exec(str);
  if (!m) {
    return ["", "", ""];
  }
  return [m[1], m[2], m[3]];
}
function abcToScientificNotation(str) {
  const [acc, letter, oct] = tokenize(str);
  if (letter === "") {
    return "";
  }
  let o = 4;
  for (let i = 0; i < oct.length; i++) {
    o += oct.charAt(i) === "," ? -1 : 1;
  }
  const a = acc[0] === "_" ? acc.replace(/_/g, "b") : acc[0] === "^" ? acc.replace(/\^/g, "#") : "";
  return letter.charCodeAt(0) > 96 ? letter.toUpperCase() + a + (o + 1) : letter + a + o;
}
function scientificToAbcNotation(str) {
  const n = note(str);
  if (n.empty || !n.oct && n.oct !== 0) {
    return "";
  }
  const { letter, acc, oct } = n;
  const a = acc[0] === "b" ? acc.replace(/b/g, "_") : acc.replace(/#/g, "^");
  const l = oct > 4 ? letter.toLowerCase() : letter;
  const o = oct === 5 ? "" : oct > 4 ? fillStr("'", oct - 5) : fillStr(",", 4 - oct);
  return a + l + o;
}
function transpose3(note22, interval6) {
  return scientificToAbcNotation(transpose(abcToScientificNotation(note22), interval6));
}
function distance2(from, to) {
  return distance(abcToScientificNotation(from), abcToScientificNotation(to));
}
var abc_notation_default = {
  abcToScientificNotation,
  scientificToAbcNotation,
  tokenize,
  transpose: transpose3,
  distance: distance2
};

// node_modules/@tonaljs/array/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  compact: () => compact2,
  permutations: () => permutations,
  range: () => range2,
  rotate: () => rotate2,
  shuffle: () => shuffle,
  sortedNoteNames: () => sortedNoteNames,
  sortedUniqNoteNames: () => sortedUniqNoteNames
});
function ascR(b, n) {
  const a = [];
  for (; n--; a[n] = n + b)
    ;
  return a;
}
function descR(b, n) {
  const a = [];
  for (; n--; a[n] = b - n)
    ;
  return a;
}
function range2(from, to) {
  return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
}
function rotate2(times, arr) {
  const len = arr.length;
  const n = (times % len + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}
function compact2(arr) {
  return arr.filter((n) => n === 0 || n);
}
function sortedNoteNames(notes2) {
  const valid = notes2.map((n) => note(n)).filter((n) => !n.empty);
  return valid.sort((a, b) => a.height - b.height).map((n) => n.name);
}
function sortedUniqNoteNames(arr) {
  return sortedNoteNames(arr).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
function shuffle(arr, rnd = Math.random) {
  let i;
  let t;
  let m = arr.length;
  while (m) {
    i = Math.floor(rnd() * m--);
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
}
function permutations(arr) {
  if (arr.length === 0) {
    return [[]];
  }
  return permutations(arr.slice(1)).reduce((acc, perm) => {
    return acc.concat(
      arr.map((e, pos) => {
        const newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
}

// node_modules/@tonaljs/chord-detect/node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default = CHORDS;
var NoChordType = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary = [];
var index = {};
function all2() {
  return dictionary.slice();
}
function add(intervals, aliases, fullName) {
  const quality2 = getQuality(intervals);
  const chord2 = {
    ...get(intervals),
    name: fullName || "",
    quality: quality2,
    intervals,
    aliases
  };
  dictionary.push(chord2);
  if (chord2.name) {
    index[chord2.name] = chord2;
  }
  index[chord2.setNum] = chord2;
  index[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias(chord2, alias));
}
function addAlias(chord2, alias) {
  index[alias] = chord2;
}
function getQuality(intervals) {
  const has = (interval6) => intervals.indexOf(interval6) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default.forEach(
  ([ivls, fullName, names22]) => add(ivls.split(" "), names22.split(" "), fullName)
);
dictionary.sort((a, b) => a.setNum - b.setNum);

// node_modules/@tonaljs/chord-detect/dist/index.mjs
var namedSet = (notes2) => {
  const pcToName = notes2.reduce((record, n) => {
    const chroma2 = note(n).chroma;
    if (chroma2 !== void 0) {
      record[chroma2] = record[chroma2] || note(n).name;
    }
    return record;
  }, {});
  return (chroma2) => pcToName[chroma2];
};
function detect(source, options = {}) {
  const notes2 = source.map((n) => note(n).pc).filter((x) => x);
  if (note.length === 0) {
    return [];
  }
  const found = findMatches(notes2, 1, options);
  return found.filter((chord2) => chord2.weight).sort((a, b) => b.weight - a.weight).map((chord2) => chord2.name);
}
var BITMASK = {
  // 3m 000100000000
  // 3M 000010000000
  anyThirds: 384,
  // 5P 000000010000
  perfectFifth: 16,
  // 5d 000000100000
  // 5A 000000001000
  nonPerfectFifths: 40,
  anySeventh: 3
};
var testChromaNumber = (bitmask) => (chromaNumber) => Boolean(chromaNumber & bitmask);
var hasAnyThird = testChromaNumber(BITMASK.anyThirds);
var hasPerfectFifth = testChromaNumber(BITMASK.perfectFifth);
var hasAnySeventh = testChromaNumber(BITMASK.anySeventh);
var hasNonPerfectFifth = testChromaNumber(BITMASK.nonPerfectFifths);
function hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2) {
  const chromaNumber = parseInt(chordType2.chroma, 2);
  return hasAnyThird(chromaNumber) && hasPerfectFifth(chromaNumber) && hasAnySeventh(chromaNumber);
}
function withPerfectFifth(chroma2) {
  const chromaNumber = parseInt(chroma2, 2);
  return hasNonPerfectFifth(chromaNumber) ? chroma2 : (chromaNumber | 16).toString(2);
}
function findMatches(notes2, weight, options) {
  const tonic = notes2[0];
  const tonicChroma = note(tonic).chroma;
  const noteName = namedSet(notes2);
  const allModes = modes(notes2, false);
  const found = [];
  allModes.forEach((mode2, index5) => {
    const modeWithPerfectFifth = options.assumePerfectFifth && withPerfectFifth(mode2);
    const chordTypes = all2().filter((chordType2) => {
      if (options.assumePerfectFifth && hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2)) {
        return chordType2.chroma === modeWithPerfectFifth;
      }
      return chordType2.chroma === mode2;
    });
    chordTypes.forEach((chordType2) => {
      const chordName = chordType2.aliases[0];
      const baseNote = noteName(index5);
      const isInversion = index5 !== tonicChroma;
      if (isInversion) {
        found.push({
          weight: 0.5 * weight,
          name: `${baseNote}${chordName}/${tonic}`
        });
      } else {
        found.push({ weight: 1 * weight, name: `${baseNote}${chordName}` });
      }
    });
  });
  return found;
}

// node_modules/@tonaljs/core/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  accToAlt: () => accToAlt2,
  altToAcc: () => altToAcc2,
  chroma: () => chroma,
  coordToInterval: () => coordToInterval,
  coordToNote: () => coordToNote,
  coordinates: () => coordinates,
  deprecate: () => deprecate,
  distance: () => distance3,
  fillStr: () => fillStr4,
  height: () => height,
  interval: () => interval,
  isNamed: () => isNamed,
  isNamedPitch: () => isNamedPitch,
  isPitch: () => isPitch,
  midi: () => midi,
  note: () => note2,
  pitch: () => pitch,
  stepToLetter: () => stepToLetter,
  tokenizeInterval: () => tokenizeInterval,
  tokenizeNote: () => tokenizeNote2,
  tonicIntervalsTransposer: () => tonicIntervalsTransposer,
  transpose: () => transpose4
});

// node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
var SIZES = [0, 2, 4, 5, 7, 9, 11];
var chroma = ({ step, alt }) => (SIZES[step] + alt + 120) % 12;
var height = ({ step, alt, oct, dir = 1 }) => dir * (SIZES[step] + alt + 12 * (oct === void 0 ? -100 : oct));
var midi = (pitch22) => {
  const h = height(pitch22);
  return pitch22.oct !== void 0 && h >= -12 && h <= 115 ? h + 12 : null;
};
function isPitch(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" ? true : false;
}
var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS = FIFTHS.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
function pitch(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS[unaltered(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS[step];
  return { step, alt, oct, dir };
}
function unaltered(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr2 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval = { empty: true, name: "", acc: "" };
var INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX2 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$"
);
function tokenizeInterval(str) {
  const m = REGEX2.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache = {};
function interval(src) {
  return typeof src === "string" ? cache[src] || (cache[src] = parse(src)) : isPitch(src) ? interval(pitchName(src)) : isNamedPitch(src) ? interval(src.name) : NoInterval;
}
var SIZES2 = [0, 2, 4, 5, 7, 9, 11];
var TYPES = "PMMPPMM";
function parse(str) {
  const tokens = tokenizeInterval(str);
  if (tokens[0] === "") {
    return NoInterval;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t = TYPES[step];
  if (t === "M" && q === "P") {
    return NoInterval;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones2 = dir * (SIZES2[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES2[step] + alt) % 12 + 12) % 12;
  const coord = coordinates({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma2,
    coord,
    oct
  };
}
function coordToInterval(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval(pitch(ivl));
}
function qToAlt(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES[step] === "M" ? "majorable" : "perfectable";
  const name2 = d + num2 + altToQ(type, alt);
  return name2;
}
function altToQ(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr2("A", alt);
  } else {
    return fillStr2("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/core/node_modules/@tonaljs/pitch-note/dist/index.mjs
var fillStr3 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoNote = { empty: true, name: "", pc: "", acc: "" };
var cache2 = /* @__PURE__ */ new Map();
var stepToLetter = (step) => "CDEFGAB".charAt(step);
var altToAcc2 = (alt) => alt < 0 ? fillStr3("b", -alt) : fillStr3("#", alt);
var accToAlt2 = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note2(src) {
  const stringSrc = JSON.stringify(src);
  const cached = cache2.get(stringSrc);
  if (cached) {
    return cached;
  }
  const value2 = typeof src === "string" ? parse2(src) : isPitch(src) ? note2(pitchName2(src)) : isNamedPitch(src) ? note2(src.name) : NoNote;
  cache2.set(stringSrc, value2);
  return value2;
}
var REGEX3 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote2(str) {
  const m = REGEX3.exec(str);
  return m ? [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]] : ["", "", "", ""];
}
function coordToNote(noteCoord) {
  return note2(pitch(noteCoord));
}
var mod = (n, m) => (n % m + m) % m;
var SEMI = [0, 2, 4, 5, 7, 9, 11];
function parse2(noteName) {
  const tokens = tokenizeNote2(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt2(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = coordinates({ step, alt, oct });
  const name2 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma2 = (SEMI[step] + alt + 120) % 12;
  const height2 = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
  const midi2 = height2 >= 0 && height2 <= 127 ? height2 : null;
  const freq = oct === void 0 ? null : Math.pow(2, (height2 - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma2,
    coord,
    freq,
    height: height2,
    letter,
    midi: midi2,
    name: name2,
    oct,
    pc,
    step
  };
}
function pitchName2(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc2(alt);
  return oct || oct === 0 ? pc + oct : pc;
}

// node_modules/@tonaljs/core/node_modules/@tonaljs/pitch-distance/dist/index.mjs
function transpose4(noteName, intervalName) {
  const note3 = note2(noteName);
  const intervalCoord = Array.isArray(intervalName) ? intervalName : interval(intervalName).coord;
  if (note3.empty || !intervalCoord || intervalCoord.length < 2) {
    return "";
  }
  const noteCoord = note3.coord;
  const tr = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote(tr).name;
}
function tonicIntervalsTransposer(intervals, tonic) {
  const len = intervals.length;
  return (normalized) => {
    if (!tonic)
      return "";
    const index5 = normalized < 0 ? (len - -normalized % len) % len : normalized % len;
    const octaves = Math.floor(normalized / len);
    const root = transpose4(tonic, [0, octaves]);
    return transpose4(root, intervals[index5]);
  };
}
function distance3(fromNote, toNote) {
  const from = note2(fromNote);
  const to = note2(toNote);
  if (from.empty || to.empty) {
    return "";
  }
  const fcoord = from.coord;
  const tcoord = to.coord;
  const fifths = tcoord[0] - fcoord[0];
  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);
  const forceDescending = to.height === from.height && to.midi !== null && from.midi !== null && from.step > to.step;
  return coordToInterval([fifths, octs], forceDescending).name;
}

// node_modules/@tonaljs/core/dist/index.mjs
var fillStr4 = (s, n) => Array(Math.abs(n) + 1).join(s);
function deprecate(original, alternative, fn) {
  return function(...args) {
    console.warn(`${original} is deprecated. Use ${alternative}.`);
    return fn.apply(this, args);
  };
}
var isNamed = deprecate("isNamed", "isNamedPitch", isNamedPitch);

// node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS2 = [
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default2 = CHORDS2;
var NoChordType2 = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary2 = [];
var index2 = {};
function get3(type) {
  return index2[type] || NoChordType2;
}
var chordType = deprecate("ChordType.chordType", "ChordType.get", get3);
function names() {
  return dictionary2.map((chord2) => chord2.name).filter((x) => x);
}
function symbols() {
  return dictionary2.map((chord2) => chord2.aliases[0]).filter((x) => x);
}
function keys() {
  return Object.keys(index2);
}
function all3() {
  return dictionary2.slice();
}
var entries = deprecate("ChordType.entries", "ChordType.all", all3);
function removeAll() {
  dictionary2 = [];
  index2 = {};
}
function add2(intervals, aliases, fullName) {
  const quality2 = getQuality2(intervals);
  const chord2 = {
    ...get(intervals),
    name: fullName || "",
    quality: quality2,
    intervals,
    aliases
  };
  dictionary2.push(chord2);
  if (chord2.name) {
    index2[chord2.name] = chord2;
  }
  index2[chord2.setNum] = chord2;
  index2[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias2(chord2, alias));
}
function addAlias2(chord2, alias) {
  index2[alias] = chord2;
}
function getQuality2(intervals) {
  const has = (interval6) => intervals.indexOf(interval6) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default2.forEach(
  ([ivls, fullName, names22]) => add2(ivls.split(" "), names22.split(" "), fullName)
);
dictionary2.sort((a, b) => a.setNum - b.setNum);
var chord_type_default = {
  names,
  symbols,
  get: get3,
  all: all3,
  add: add2,
  removeAll,
  keys,
  entries,
  chordType
};

// node_modules/@tonaljs/tonal/node_modules/@tonaljs/chord/dist/index.mjs
var NoChord = {
  empty: true,
  name: "",
  symbol: "",
  root: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize2(name2) {
  const [letter, acc, oct, type] = tokenizeNote2(name2);
  if (letter === "") {
    return ["", name2];
  }
  if (letter === "A" && type === "ug") {
    return ["", "aug"];
  }
  return [letter + acc, oct + type];
}
function get4(src) {
  if (src === "") {
    return NoChord;
  }
  if (Array.isArray(src) && src.length === 2) {
    return getChord(src[1], src[0]);
  } else {
    const [tonic, type] = tokenize2(src);
    const chord2 = getChord(type, tonic);
    return chord2.empty ? getChord(src) : chord2;
  }
}
function getChord(typeName, optionalTonic, optionalRoot) {
  const type = get3(typeName);
  const tonic = note2(optionalTonic || "");
  const root = note2(optionalRoot || "");
  if (type.empty || optionalTonic && tonic.empty || optionalRoot && root.empty) {
    return NoChord;
  }
  const rootInterval = distance3(tonic.pc, root.pc);
  const rootDegree = type.intervals.indexOf(rootInterval) + 1;
  if (!root.empty && !rootDegree) {
    return NoChord;
  }
  const intervals = Array.from(type.intervals);
  for (let i = 1; i < rootDegree; i++) {
    const num2 = intervals[0][0];
    const quality2 = intervals[0][1];
    const newNum = parseInt(num2, 10) + 7;
    intervals.push(`${newNum}${quality2}`);
    intervals.shift();
  }
  const notes2 = tonic.empty ? [] : intervals.map((i) => transpose4(tonic, i));
  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];
  const symbol = `${tonic.empty ? "" : tonic.pc}${typeName}${root.empty || rootDegree <= 1 ? "" : "/" + root.pc}`;
  const name2 = `${optionalTonic ? tonic.pc + " " : ""}${type.name}${rootDegree > 1 && optionalRoot ? " over " + root.pc : ""}`;
  return {
    ...type,
    name: name2,
    symbol,
    type: type.name,
    root: root.name,
    intervals,
    rootDegree,
    tonic: tonic.name,
    notes: notes2
  };
}
var chord = deprecate("Chord.chord", "Chord.get", get4);
function transpose5(chordName, interval6) {
  const [tonic, type] = tokenize2(chordName);
  if (!tonic) {
    return chordName;
  }
  return transpose4(tonic, interval6) + type;
}
function chordScales(name2) {
  const s = get4(name2);
  const isChordIncluded = isSupersetOf(s.chroma);
  return all().filter((scale) => isChordIncluded(scale.chroma)).map((scale) => scale.name);
}
function extended(chordName) {
  const s = get4(chordName);
  const isSuperset = isSupersetOf(s.chroma);
  return all3().filter((chord2) => isSuperset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function reduced(chordName) {
  const s = get4(chordName);
  const isSubset = isSubsetOf(s.chroma);
  return all3().filter((chord2) => isSubset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function degrees(chordName) {
  const { intervals, tonic } = get4(chordName);
  const transpose22 = tonicIntervalsTransposer(intervals, tonic);
  return (degree) => degree ? transpose22(degree > 0 ? degree - 1 : degree) : "";
}
function steps(chordName) {
  const { intervals, tonic } = get4(chordName);
  return tonicIntervalsTransposer(intervals, tonic);
}
var chord_default = {
  getChord,
  get: get4,
  detect,
  chordScales,
  extended,
  reduced,
  tokenize: tokenize2,
  transpose: transpose5,
  degrees,
  steps,
  chord
};

// node_modules/@tonaljs/duration-value/dist/index.mjs
var DATA = [
  [
    0.125,
    "dl",
    ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
  ],
  [0.25, "l", ["long", "longa"]],
  [0.5, "d", ["double whole", "double", "breve"]],
  [1, "w", ["whole", "semibreve"]],
  [2, "h", ["half", "minim"]],
  [4, "q", ["quarter", "crotchet"]],
  [8, "e", ["eighth", "quaver"]],
  [16, "s", ["sixteenth", "semiquaver"]],
  [32, "t", ["thirty-second", "demisemiquaver"]],
  [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
  [128, "h", ["hundred twenty-eighth"]],
  [256, "th", ["two hundred fifty-sixth"]]
];
var data_default3 = DATA;
var VALUES = [];
data_default3.forEach(
  ([denominator, shorthand, names22]) => add3(denominator, shorthand, names22)
);
var NoDuration = {
  empty: true,
  name: "",
  value: 0,
  fraction: [0, 0],
  shorthand: "",
  dots: "",
  names: []
};
function names2() {
  return VALUES.reduce((names22, duration) => {
    duration.names.forEach((name2) => names22.push(name2));
    return names22;
  }, []);
}
function shorthands() {
  return VALUES.map((dur) => dur.shorthand);
}
var REGEX4 = /^([^.]+)(\.*)$/;
function get5(name2) {
  const [_, simple, dots] = REGEX4.exec(name2) || [];
  const base = VALUES.find(
    (dur) => dur.shorthand === simple || dur.names.includes(simple)
  );
  if (!base) {
    return NoDuration;
  }
  const fraction2 = calcDots(base.fraction, dots.length);
  const value2 = fraction2[0] / fraction2[1];
  return { ...base, name: name2, dots, value: value2, fraction: fraction2 };
}
var value = (name2) => get5(name2).value;
var fraction = (name2) => get5(name2).fraction;
var duration_value_default = { names: names2, shorthands, get: get5, value, fraction };
function add3(denominator, shorthand, names22) {
  VALUES.push({
    empty: false,
    dots: "",
    name: "",
    value: 1 / denominator,
    fraction: denominator < 1 ? [1 / denominator, 1] : [1, denominator],
    shorthand,
    names: names22
  });
}
function calcDots(fraction2, dots) {
  const pow = Math.pow(2, dots);
  let numerator = fraction2[0] * pow;
  let denominator = fraction2[1] * pow;
  const base = numerator;
  for (let i = 0; i < dots; i++) {
    numerator += base / Math.pow(2, i + 1);
  }
  while (numerator % 2 === 0 && denominator % 2 === 0) {
    numerator /= 2;
    denominator /= 2;
  }
  return [numerator, denominator];
}

// node_modules/@tonaljs/interval/dist/index.mjs
function names3() {
  return "1P 2M 3M 4P 5P 6m 7m".split(" ");
}
var get6 = interval;
var name = (name2) => interval(name2).name;
var semitones = (name2) => interval(name2).semitones;
var quality = (name2) => interval(name2).q;
var num = (name2) => interval(name2).num;
function simplify(name2) {
  const i = interval(name2);
  return i.empty ? "" : i.simple + i.q;
}
function invert(name2) {
  const i = interval(name2);
  if (i.empty) {
    return "";
  }
  const step = (7 - i.step) % 7;
  const alt = i.type === "perfectable" ? -i.alt : -(i.alt + 1);
  return interval({ step, alt, oct: i.oct, dir: i.dir }).name;
}
var IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];
var IQ = "P m M m M P d P m M m M".split(" ");
function fromSemitones(semitones2) {
  const d = semitones2 < 0 ? -1 : 1;
  const n = Math.abs(semitones2);
  const c = n % 12;
  const o = Math.floor(n / 12);
  return d * (IN[c] + 7 * o) + IQ[c];
}
var distance4 = distance;
var add4 = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);
var addTo = (interval6) => (other) => add4(interval6, other);
var substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);
function transposeFifths2(interval6, fifths) {
  const ivl = get6(interval6);
  if (ivl.empty)
    return "";
  const [nFifths, nOcts, dir] = ivl.coord;
  return coordToInterval([nFifths + fifths, nOcts, dir]).name;
}
var interval_default = {
  names: names3,
  get: get6,
  name,
  num,
  semitones,
  quality,
  fromSemitones,
  distance: distance4,
  invert,
  simplify,
  add: add4,
  addTo,
  substract,
  transposeFifths: transposeFifths2
};
function combinator(fn) {
  return (a, b) => {
    const coordA = interval(a).coord;
    const coordB = interval(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval(coord).name;
    }
  };
}

// node_modules/@tonaljs/roman-numeral/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch2(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch2(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS2 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS2 = FIFTHS2.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates2(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS2[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS2[step] - 4 * alt;
  return [dir * f, dir * o];
}

// node_modules/@tonaljs/roman-numeral/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr5 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval2 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX2 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX2 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX5 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX2 + "|" + INTERVAL_SHORTHAND_REGEX2 + "$"
);
function tokenizeInterval2(str) {
  const m = REGEX5.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache3 = {};
function interval2(src) {
  return typeof src === "string" ? cache3[src] || (cache3[src] = parse3(src)) : isPitch2(src) ? interval2(pitchName3(src)) : isNamedPitch2(src) ? interval2(src.name) : NoInterval2;
}
var SIZES3 = [0, 2, 4, 5, 7, 9, 11];
var TYPES2 = "PMMPPMM";
function parse3(str) {
  const tokens = tokenizeInterval2(str);
  if (tokens[0] === "") {
    return NoInterval2;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t = TYPES2[step];
  if (t === "M" && q === "P") {
    return NoInterval2;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt2(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones2 = dir * (SIZES3[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES3[step] + alt) % 12 + 12) % 12;
  const coord = coordinates2({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma2,
    coord,
    oct
  };
}
function qToAlt2(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName3(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES2[step] === "M" ? "majorable" : "perfectable";
  const name2 = d + num2 + altToQ2(type, alt);
  return name2;
}
function altToQ2(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr5("A", alt);
  } else {
    return fillStr5("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/roman-numeral/dist/index.mjs
var NoRomanNumeral = { empty: true, name: "", chordType: "" };
var cache4 = {};
function get7(src) {
  return typeof src === "string" ? cache4[src] || (cache4[src] = parse4(src)) : typeof src === "number" ? get7(NAMES[src] || "") : isPitch2(src) ? fromPitch(src) : isNamedPitch2(src) ? get7(src.name) : NoRomanNumeral;
}
var romanNumeral = get7;
function names4(major = true) {
  return (major ? NAMES : NAMES_MINOR).slice();
}
function fromPitch(pitch6) {
  return get7(altToAcc(pitch6.alt) + NAMES[pitch6.step]);
}
var REGEX6 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
function tokenize3(str) {
  return REGEX6.exec(str) || ["", "", "", ""];
}
var ROMANS = "I II III IV V VI VII";
var NAMES = ROMANS.split(" ");
var NAMES_MINOR = ROMANS.toLowerCase().split(" ");
function parse4(src) {
  const [name2, acc, roman, chordType2] = tokenize3(src);
  if (!roman) {
    return NoRomanNumeral;
  }
  const upperRoman = roman.toUpperCase();
  const step = NAMES.indexOf(upperRoman);
  const alt = accToAlt(acc);
  const dir = 1;
  return {
    empty: false,
    name: name2,
    roman,
    interval: interval2({ step, alt, dir }).name,
    acc,
    chordType: chordType2,
    alt,
    step,
    major: roman === upperRoman,
    oct: 0,
    dir
  };
}
var roman_numeral_default = {
  names: names4,
  get: get7,
  // deprecated
  romanNumeral
};

// node_modules/@tonaljs/key/dist/index.mjs
var Empty = Object.freeze([]);
var NoKey = {
  type: "major",
  tonic: "",
  alteration: 0,
  keySignature: ""
};
var NoKeyScale = {
  tonic: "",
  grades: Empty,
  intervals: Empty,
  scale: Empty,
  triads: Empty,
  chords: Empty,
  chordsHarmonicFunction: Empty,
  chordScales: Empty
};
var NoMajorKey = {
  ...NoKey,
  ...NoKeyScale,
  type: "major",
  minorRelative: "",
  scale: Empty,
  secondaryDominants: Empty,
  secondaryDominantsMinorRelative: Empty,
  substituteDominants: Empty,
  substituteDominantsMinorRelative: Empty
};
var NoMinorKey = {
  ...NoKey,
  type: "minor",
  relativeMajor: "",
  natural: NoKeyScale,
  harmonic: NoKeyScale,
  melodic: NoKeyScale
};
var mapScaleToType = (scale, list, sep = "") => list.map((type, i) => `${scale[i]}${sep}${type}`);
function keyScale(grades, triads2, chords2, harmonicFunctions, chordScales2) {
  return (tonic) => {
    const intervals = grades.map((gr) => get7(gr).interval || "");
    const scale = intervals.map((interval6) => transpose2(tonic, interval6));
    return {
      tonic,
      grades,
      intervals,
      scale,
      triads: mapScaleToType(scale, triads2),
      chords: mapScaleToType(scale, chords2),
      chordsHarmonicFunction: harmonicFunctions.slice(),
      chordScales: mapScaleToType(scale, chordScales2, " ")
    };
  };
}
var distInFifths = (from, to) => {
  const f = note(from);
  const t = note(to);
  return f.empty || t.empty ? 0 : t.coord[0] - f.coord[0];
};
var MajorScale = keyScale(
  "I II III IV V VI VII".split(" "),
  " m m   m dim".split(" "),
  "maj7 m7 m7 maj7 7 m7 m7b5".split(" "),
  "T SD T SD D T D".split(" "),
  "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(",")
);
var NaturalScale = keyScale(
  "I II bIII IV V bVI bVII".split(" "),
  "m dim  m m  ".split(" "),
  "m7 m7b5 maj7 m7 m7 maj7 7".split(" "),
  "T SD T SD D SD SD".split(" "),
  "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(",")
);
var HarmonicScale = keyScale(
  "I II bIII IV V bVI VII".split(" "),
  "m dim aug m   dim".split(" "),
  "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "),
  "T SD T SD D SD D".split(" "),
  "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(
    ","
  )
);
var MelodicScale = keyScale(
  "I II bIII IV V VI VII".split(" "),
  "m m aug   dim dim".split(" "),
  "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "),
  "T SD T SD D  ".split(" "),
  "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(
    ","
  )
);
function majorKey(tonic) {
  const pc = note(tonic).pc;
  if (!pc) return NoMajorKey;
  const keyScale2 = MajorScale(pc);
  const alteration = distInFifths("C", pc);
  const romanInTonic = (src) => {
    const r = get7(src);
    if (r.empty) return "";
    return transpose2(tonic, r.interval) + r.chordType;
  };
  return {
    ...keyScale2,
    type: "major",
    minorRelative: transpose2(pc, "-3m"),
    alteration,
    keySignature: altToAcc(alteration),
    secondaryDominants: "- VI7 VII7 I7 II7 III7 -".split(" ").map(romanInTonic),
    secondaryDominantsMinorRelative: "- IIIm7b5 IV#m7 Vm7 VIm7 VIIm7b5 -".split(" ").map(romanInTonic),
    substituteDominants: "- bIII7 IV7 bV7 bVI7 bVII7 -".split(" ").map(romanInTonic),
    substituteDominantsMinorRelative: "- IIIm7 Im7 IIbm7 VIm7 IVm7 -".split(" ").map(romanInTonic)
  };
}
function minorKey(tnc) {
  const pc = note(tnc).pc;
  if (!pc) return NoMinorKey;
  const alteration = distInFifths("C", pc) - 3;
  return {
    type: "minor",
    tonic: pc,
    relativeMajor: transpose2(pc, "3m"),
    alteration,
    keySignature: altToAcc(alteration),
    natural: NaturalScale(pc),
    harmonic: HarmonicScale(pc),
    melodic: MelodicScale(pc)
  };
}
function majorTonicFromKeySignature(sig) {
  if (typeof sig === "number") {
    return transposeFifths("C", sig);
  } else if (typeof sig === "string" && /^b+|#+$/.test(sig)) {
    return transposeFifths("C", accToAlt(sig));
  }
  return null;
}
var key_default = { majorKey, majorTonicFromKeySignature, minorKey };

// node_modules/@tonaljs/mode/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch3(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch3(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS3 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS3 = FIFTHS3.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates3(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS3[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS3[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS2 = [3, 0, 4, 1, 5, 2, 6];
function pitch3(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS2[unaltered2(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS3[step];
  return { step, alt, oct, dir };
}
function unaltered2(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/mode/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr6 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval3 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX3 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX3 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX7 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX3 + "|" + INTERVAL_SHORTHAND_REGEX3 + "$"
);
function tokenizeInterval3(str) {
  const m = REGEX7.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache5 = {};
function interval3(src) {
  return typeof src === "string" ? cache5[src] || (cache5[src] = parse5(src)) : isPitch3(src) ? interval3(pitchName4(src)) : isNamedPitch3(src) ? interval3(src.name) : NoInterval3;
}
var SIZES4 = [0, 2, 4, 5, 7, 9, 11];
var TYPES3 = "PMMPPMM";
function parse5(str) {
  const tokens = tokenizeInterval3(str);
  if (tokens[0] === "") {
    return NoInterval3;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t = TYPES3[step];
  if (t === "M" && q === "P") {
    return NoInterval3;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt3(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones2 = dir * (SIZES4[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES4[step] + alt) % 12 + 12) % 12;
  const coord = coordinates3({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma2,
    coord,
    oct
  };
}
function coordToInterval2(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval3(pitch3(ivl));
}
function qToAlt3(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName4(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES3[step] === "M" ? "majorable" : "perfectable";
  const name2 = d + num2 + altToQ3(type, alt);
  return name2;
}
function altToQ3(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr6("A", alt);
  } else {
    return fillStr6("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/mode/node_modules/@tonaljs/interval/dist/index.mjs
var get8 = interval3;
function simplify2(name2) {
  const i = interval3(name2);
  return i.empty ? "" : i.simple + i.q;
}
var IQ2 = "P m M m M P d P m M m M".split(" ");
var add5 = combinator2((a, b) => [a[0] + b[0], a[1] + b[1]]);
var subtract = combinator2((a, b) => [a[0] - b[0], a[1] - b[1]]);
function transposeFifths3(interval6, fifths) {
  const ivl = get8(interval6);
  if (ivl.empty) return "";
  const [nFifths, nOcts, dir] = ivl.coord;
  return coordToInterval2([nFifths + fifths, nOcts, dir]).name;
}
function combinator2(fn) {
  return (a, b) => {
    const coordA = interval3(a).coord;
    const coordB = interval3(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval2(coord).name;
    }
  };
}

// node_modules/@tonaljs/mode/dist/index.mjs
var MODES = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
];
var NoMode = {
  ...EmptyPcset,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
};
var modes2 = MODES.map(toMode);
var index3 = {};
modes2.forEach((mode2) => {
  index3[mode2.name] = mode2;
  mode2.aliases.forEach((alias) => {
    index3[alias] = mode2;
  });
});
function get9(name2) {
  return typeof name2 === "string" ? index3[name2.toLowerCase()] || NoMode : name2 && name2.name ? get9(name2.name) : NoMode;
}
var mode = get9;
function all4() {
  return modes2.slice();
}
var entries2 = all4;
function names5() {
  return modes2.map((mode2) => mode2.name);
}
function toMode(mode2) {
  const [modeNum, setNum, alt, name2, triad, seventh, alias] = mode2;
  const aliases = alias ? [alias] : [];
  const chroma2 = Number(setNum).toString(2);
  const intervals = get2(name2).intervals;
  return {
    empty: false,
    intervals,
    modeNum,
    chroma: chroma2,
    normalized: chroma2,
    name: name2,
    setNum,
    alt,
    triad,
    seventh,
    aliases
  };
}
function notes(modeName, tonic) {
  return get9(modeName).intervals.map((ivl) => transpose(tonic, ivl));
}
function chords(chords2) {
  return (modeName, tonic) => {
    const mode2 = get9(modeName);
    if (mode2.empty) return [];
    const triads2 = rotate(mode2.modeNum, chords2);
    const tonics = mode2.intervals.map((i) => transpose(tonic, i));
    return triads2.map((triad, i) => tonics[i] + triad);
  };
}
var triads = chords(MODES.map((x) => x[4]));
var seventhChords = chords(MODES.map((x) => x[5]));
function distance5(destination, source) {
  const from = get9(source);
  const to = get9(destination);
  if (from.empty || to.empty) return "";
  return simplify2(transposeFifths3("1P", to.alt - from.alt));
}
function relativeTonic(destination, source, tonic) {
  return transpose(tonic, distance5(destination, source));
}
var mode_default = {
  get: get9,
  names: names5,
  all: all4,
  distance: distance5,
  relativeTonic,
  notes,
  triads,
  seventhChords,
  // deprecated
  entries: entries2,
  mode
};

// node_modules/@tonaljs/chord/node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS3 = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default4 = CHORDS3;
var NoChordType3 = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary3 = [];
var index4 = {};
function add6(intervals, aliases, fullName) {
  const quality2 = getQuality3(intervals);
  const chord2 = {
    ...get(intervals),
    name: fullName || "",
    quality: quality2,
    intervals,
    aliases
  };
  dictionary3.push(chord2);
  if (chord2.name) {
    index4[chord2.name] = chord2;
  }
  index4[chord2.setNum] = chord2;
  index4[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias3(chord2, alias));
}
function addAlias3(chord2, alias) {
  index4[alias] = chord2;
}
function getQuality3(intervals) {
  const has = (interval6) => intervals.indexOf(interval6) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default4.forEach(
  ([ivls, fullName, names22]) => add6(ivls.split(" "), names22.split(" "), fullName)
);
dictionary3.sort((a, b) => a.setNum - b.setNum);

// node_modules/@tonaljs/chord/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch4(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch4(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS4 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS4 = FIFTHS4.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates4(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS4[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS4[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS3 = [3, 0, 4, 1, 5, 2, 6];
function pitch4(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS3[unaltered3(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS4[step];
  return { step, alt, oct, dir };
}
function unaltered3(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/chord/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr7 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval4 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX4 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX4 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX8 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX4 + "|" + INTERVAL_SHORTHAND_REGEX4 + "$"
);
function tokenizeInterval4(str) {
  const m = REGEX8.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache6 = {};
function interval4(src) {
  return typeof src === "string" ? cache6[src] || (cache6[src] = parse6(src)) : isPitch4(src) ? interval4(pitchName5(src)) : isNamedPitch4(src) ? interval4(src.name) : NoInterval4;
}
var SIZES5 = [0, 2, 4, 5, 7, 9, 11];
var TYPES4 = "PMMPPMM";
function parse6(str) {
  const tokens = tokenizeInterval4(str);
  if (tokens[0] === "") {
    return NoInterval4;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t = TYPES4[step];
  if (t === "M" && q === "P") {
    return NoInterval4;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt4(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones2 = dir * (SIZES5[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES5[step] + alt) % 12 + 12) % 12;
  const coord = coordinates4({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma2,
    coord,
    oct
  };
}
function coordToInterval3(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval4(pitch4(ivl));
}
function qToAlt4(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName5(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES4[step] === "M" ? "majorable" : "perfectable";
  const name2 = d + num2 + altToQ4(type, alt);
  return name2;
}
function altToQ4(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr7("A", alt);
  } else {
    return fillStr7("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/chord/node_modules/@tonaljs/interval/dist/index.mjs
var IQ3 = "P m M m M P d P m M m M".split(" ");
var add7 = combinator3((a, b) => [a[0] + b[0], a[1] + b[1]]);
var subtract2 = combinator3((a, b) => [a[0] - b[0], a[1] - b[1]]);
function combinator3(fn) {
  return (a, b) => {
    const coordA = interval4(a).coord;
    const coordB = interval4(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval3(coord).name;
    }
  };
}

// node_modules/@tonaljs/chord/dist/index.mjs
function tokenize4(name2) {
  const [letter, acc, oct, type] = tokenizeNote(name2);
  if (letter === "") {
    return tokenizeBass("", name2);
  } else if (letter === "A" && type === "ug") {
    return tokenizeBass("", "aug");
  } else {
    return tokenizeBass(letter + acc, oct + type);
  }
}
function tokenizeBass(note22, chord2) {
  const split = chord2.split("/");
  if (split.length === 1) {
    return [note22, split[0], ""];
  }
  const [letter, acc, oct, type] = tokenizeNote(split[1]);
  if (letter !== "" && oct === "" && type === "") {
    return [note22, split[0], letter + acc];
  } else {
    return [note22, chord2, ""];
  }
}

// node_modules/@tonaljs/progression/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch5(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch5(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS5 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS5 = FIFTHS5.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates5(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS5[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS5[step] - 4 * alt;
  return [dir * f, dir * o];
}

// node_modules/@tonaljs/progression/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr8 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval5 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX5 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX5 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX9 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX5 + "|" + INTERVAL_SHORTHAND_REGEX5 + "$"
);
function tokenizeInterval5(str) {
  const m = REGEX9.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache7 = {};
function interval5(src) {
  return typeof src === "string" ? cache7[src] || (cache7[src] = parse7(src)) : isPitch5(src) ? interval5(pitchName6(src)) : isNamedPitch5(src) ? interval5(src.name) : NoInterval5;
}
var SIZES6 = [0, 2, 4, 5, 7, 9, 11];
var TYPES5 = "PMMPPMM";
function parse7(str) {
  const tokens = tokenizeInterval5(str);
  if (tokens[0] === "") {
    return NoInterval5;
  }
  const num2 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num2) - 1) % 7;
  const t = TYPES5[step];
  if (t === "M" && q === "P") {
    return NoInterval5;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name2 = "" + num2 + q;
  const dir = num2 < 0 ? -1 : 1;
  const simple = num2 === 8 || num2 === -8 ? num2 : dir * (step + 1);
  const alt = qToAlt5(type, q);
  const oct = Math.floor((Math.abs(num2) - 1) / 7);
  const semitones2 = dir * (SIZES6[step] + alt + 12 * oct);
  const chroma2 = (dir * (SIZES6[step] + alt) % 12 + 12) % 12;
  const coord = coordinates5({ step, alt, oct, dir });
  return {
    empty: false,
    name: name2,
    num: num2,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma2,
    coord,
    oct
  };
}
function qToAlt5(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName6(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num2 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES5[step] === "M" ? "majorable" : "perfectable";
  const name2 = d + num2 + altToQ5(type, alt);
  return name2;
}
function altToQ5(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr8("A", alt);
  } else {
    return fillStr8("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/progression/dist/index.mjs
function fromRomanNumerals(tonic, chords2) {
  const romanNumerals = chords2.map(get7);
  return romanNumerals.map(
    (rn) => transpose(tonic, interval5(rn)) + rn.chordType
  );
}
function toRomanNumerals(tonic, chords2) {
  return chords2.map((chord2) => {
    const [note3, chordType2] = tokenize4(chord2);
    const intervalName = distance(tonic, note3);
    const roman = get7(interval5(intervalName));
    return roman.name + chordType2;
  });
}
var progression_default = { fromRomanNumerals, toRomanNumerals };

// node_modules/@tonaljs/range/dist/index.mjs
function numeric(notes2) {
  const midi2 = compact(
    notes2.map((note3) => typeof note3 === "number" ? note3 : toMidi(note3))
  );
  if (!notes2.length || midi2.length !== notes2.length) {
    return [];
  }
  return midi2.reduce(
    (result, note3) => {
      const last = result[result.length - 1];
      return result.concat(range(last, note3).slice(1));
    },
    [midi2[0]]
  );
}
function chromatic(notes2, options) {
  return numeric(notes2).map((midi2) => midiToNoteName(midi2, options));
}
var range_default = { numeric, chromatic };

// node_modules/@tonaljs/time-signature/dist/index.mjs
var NONE = {
  empty: true,
  name: "",
  upper: void 0,
  lower: void 0,
  type: void 0,
  additive: []
};
var NAMES2 = ["4/4", "3/4", "2/4", "2/2", "12/8", "9/8", "6/8", "3/8"];
function names6() {
  return NAMES2.slice();
}
var REGEX10 = /^(\d*\d(?:\+\d)*)\/(\d+)$/;
var CACHE = /* @__PURE__ */ new Map();
function get11(literal) {
  const stringifiedLiteral = JSON.stringify(literal);
  const cached = CACHE.get(stringifiedLiteral);
  if (cached) {
    return cached;
  }
  const ts = build(parse8(literal));
  CACHE.set(stringifiedLiteral, ts);
  return ts;
}
function parse8(literal) {
  if (typeof literal === "string") {
    const [_, up2, low] = REGEX10.exec(literal) || [];
    return parse8([up2, low]);
  }
  const [up, down] = literal;
  const denominator = +down;
  if (typeof up === "number") {
    return [up, denominator];
  }
  const list = up.split("+").map((n) => +n);
  return list.length === 1 ? [list[0], denominator] : [list, denominator];
}
var time_signature_default = { names: names6, parse: parse8, get: get11 };
var isPowerOfTwo = (x) => Math.log(x) / Math.log(2) % 1 === 0;
function build([up, down]) {
  const upper = Array.isArray(up) ? up.reduce((a, b) => a + b, 0) : up;
  const lower = down;
  if (upper === 0 || lower === 0) {
    return NONE;
  }
  const name2 = Array.isArray(up) ? `${up.join("+")}/${down}` : `${up}/${down}`;
  const additive = Array.isArray(up) ? up : [];
  const type = lower === 4 || lower === 2 ? "simple" : lower === 8 && upper % 3 === 0 ? "compound" : isPowerOfTwo(lower) ? "irregular" : "irrational";
  return {
    empty: false,
    name: name2,
    type,
    upper,
    lower,
    additive
  };
}

// node_modules/@tonaljs/tonal/dist/index.mjs
var Tonal = dist_exports2;
var PcSet = pcset_default;
var ChordDictionary = chord_type_default;
var ScaleDictionary = scale_type_default;
export {
  abc_notation_default as AbcNotation,
  dist_exports as Array,
  chord_default as Chord,
  ChordDictionary,
  chord_type_default as ChordType,
  collection_default as Collection,
  dist_exports2 as Core,
  duration_value_default as DurationValue,
  interval_default as Interval,
  key_default as Key,
  midi_default as Midi,
  mode_default as Mode,
  note_default as Note,
  PcSet,
  pcset_default as Pcset,
  progression_default as Progression,
  range_default as Range,
  roman_numeral_default as RomanNumeral,
  scale_default as Scale,
  ScaleDictionary,
  scale_type_default as ScaleType,
  time_signature_default as TimeSignature,
  Tonal,
  accToAlt2 as accToAlt,
  altToAcc2 as altToAcc,
  chroma,
  coordToInterval,
  coordToNote,
  coordinates,
  deprecate,
  distance3 as distance,
  fillStr4 as fillStr,
  height,
  interval,
  isNamed,
  isNamedPitch,
  isPitch,
  midi,
  note2 as note,
  pitch,
  stepToLetter,
  tokenizeInterval,
  tokenizeNote2 as tokenizeNote,
  tonicIntervalsTransposer,
  transpose4 as transpose
};
//# sourceMappingURL=@tonaljs_tonal.js.map
